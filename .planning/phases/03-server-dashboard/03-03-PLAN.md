---
phase: 03-server-dashboard
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/server/models.py
  - backend/server/logs.py
  - backend/server/websocket.py
  - backend/server/routes.py
  - backend/main.py
autonomous: true

must_haves:
  truths:
    - "WebSocket endpoint accepts connection for log streaming"
    - "Log types nginx-access, nginx-error, php-fpm, mysql are supported"
    - "Client receives log lines as JSON messages"
    - "Invalid log type closes connection with error code"
    - "Only allowlisted log paths can be accessed"
    - "REST endpoint returns recent log lines for initial load"
  artifacts:
    - path: "backend/server/models.py"
      provides: "LogEntry, LogType models"
      contains: "class LogType"
    - path: "backend/server/logs.py"
      provides: "Log file reading functions"
      exports: ["tail_log", "LOG_PATHS"]
    - path: "backend/server/websocket.py"
      provides: "WebSocket connection manager"
      contains: "class LogConnectionManager"
    - path: "backend/server/routes.py"
      provides: "WebSocket and REST log endpoints"
      contains: "@router.websocket"
  key_links:
    - from: "backend/server/routes.py"
      to: "backend/server/logs.py"
      via: "import tail_log"
      pattern: "from backend.server.logs import"
    - from: "backend/server/routes.py"
      to: "backend/server/websocket.py"
      via: "import LogConnectionManager"
      pattern: "from backend.server.websocket import"
    - from: "backend/server/logs.py"
      to: "log files"
      via: "aiofiles read"
      pattern: "aiofiles.open"
---

<objective>
Create WebSocket-based real-time log viewer with REST fallback for initial load.

Purpose: Stream log file updates to connected dashboard clients for nginx, php-fpm, and mysql logs. Provide REST endpoint for loading recent lines on page load.

Output: Working WebSocket at `/api/v1/server/logs/{log_type}/ws` and REST at `/api/v1/server/logs/{log_type}`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-server-dashboard/03-RESEARCH.md
@.planning/phases/03-server-dashboard/03-CONTEXT.md

# Existing patterns
@backend/wordops/routes.py
@backend/auth/dependencies.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create log models and file reader</name>
  <files>
    backend/server/models.py
    backend/server/logs.py
  </files>
  <action>
**models.py** (add to existing):
- `LogType` enum:
  - `NGINX_ACCESS = "nginx-access"`
  - `NGINX_ERROR = "nginx-error"`
  - `PHP_FPM = "php-fpm"`
  - `MYSQL = "mysql"`
- `LogEntry` model:
  - `lines: list[str]`
  - `log_type: LogType`
  - `timestamp: int` (Unix timestamp of read)

**logs.py:**
Security: Hardcoded path mapping (NEVER construct from user input):
```python
LOG_PATHS: dict[str, str] = {
    "nginx-access": "/var/log/nginx/access.log",
    "nginx-error": "/var/log/nginx/error.log",
    "php-fpm": "/var/log/php8.2-fpm.log",
    "mysql": "/var/log/mysql/error.log",
}
```

Functions:
- `def validate_log_type(log_type: str) -> bool` - check if in LOG_PATHS
- `async def tail_log(log_type: str, lines: int = 50) -> list[str]`
  - Validate log_type against LOG_PATHS (raise ValueError if invalid)
  - Use aiofiles to read file
  - Return last N lines
  - Handle FileNotFoundError gracefully (return empty list with warning log)
  - Handle PermissionError (return empty list, log warning)
  - Limit lines to max 500 to prevent memory issues

Install aiofiles if not in dependencies:
```bash
pip install aiofiles
```
Add to pyproject.toml dependencies.
  </action>
  <verify>
python -c "from backend.server.models import LogType, LogEntry; print('Log models OK')"
python -c "from backend.server.logs import LOG_PATHS, validate_log_type, tail_log; print('nginx-access valid:', validate_log_type('nginx-access')); print('hack invalid:', validate_log_type('../../../etc/passwd'))"
  </verify>
  <done>Log models and secure file reader exist with hardcoded path mapping</done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket manager and log endpoints</name>
  <files>
    backend/server/websocket.py
    backend/server/routes.py
    backend/main.py
  </files>
  <action>
**websocket.py:**
```python
from fastapi import WebSocket
from typing import Dict, List

class LogConnectionManager:
    """Manages WebSocket connections for log streaming."""

    def __init__(self):
        self.active_connections: Dict[str, List[WebSocket]] = {}

    async def connect(self, websocket: WebSocket, log_type: str):
        await websocket.accept()
        if log_type not in self.active_connections:
            self.active_connections[log_type] = []
        self.active_connections[log_type].append(websocket)

    def disconnect(self, websocket: WebSocket, log_type: str):
        if log_type in self.active_connections:
            if websocket in self.active_connections[log_type]:
                self.active_connections[log_type].remove(websocket)

    async def send_lines(self, websocket: WebSocket, lines: list[str]):
        await websocket.send_json({"lines": lines})

# Singleton instance
log_manager = LogConnectionManager()
```

**routes.py** (add to existing):

REST endpoint for initial load:
**GET /api/v1/server/logs/{log_type}**
- Requires authentication
- Path param: `log_type: str`
- Query param: `lines: int = 50` (max 500)
- Returns: `LogEntry`
- Validate log_type (400 if invalid)
- Call `tail_log(log_type, lines)`

WebSocket endpoint for streaming:
**WebSocket /api/v1/server/logs/{log_type}/ws**
- Path param: `log_type: str`
- Query param: `token: str` (JWT for WebSocket auth)
- Validate token on connect (close with 4001 if invalid)
- Validate log_type (close with 4000 if invalid)
- Send initial 50 lines on connect
- Poll every 2 seconds for new lines
- Send only new lines (track last read position)
- Handle WebSocketDisconnect with proper cleanup

WebSocket auth pattern (since headers don't work well with WebSocket):
```python
from backend.auth.utils import decode_token
from fastapi import WebSocket, Query

@router.websocket("/logs/{log_type}/ws")
async def log_stream(
    websocket: WebSocket,
    log_type: str,
    token: str = Query(...),
):
    # Validate token
    try:
        payload = decode_token(token)
        if payload is None:
            await websocket.close(code=4001)
            return
    except Exception:
        await websocket.close(code=4001)
        return

    # Validate log type
    if not validate_log_type(log_type):
        await websocket.close(code=4000)
        return

    await log_manager.connect(websocket, log_type)
    try:
        # Send initial lines
        lines = await tail_log(log_type, 50)
        await log_manager.send_lines(websocket, lines)

        # Poll for updates
        while True:
            await asyncio.sleep(2)
            lines = await tail_log(log_type, 50)
            await log_manager.send_lines(websocket, lines)
    except WebSocketDisconnect:
        log_manager.disconnect(websocket, log_type)
```

**main.py:**
No changes needed if routes.py already included from 03-01.
  </action>
  <verify>
# Verify routes registered:
curl -s http://localhost:8000/openapi.json | python -c "import sys,json; paths=json.load(sys.stdin)['paths']; print('/api/v1/server/logs/{log_type}' in paths)"

# Test REST endpoint (requires auth):
curl -s http://localhost:8000/api/v1/server/logs/nginx-access -H "Authorization: Bearer ${TOKEN}" | head -10

# Test invalid log type (should return 400):
curl -s -o /dev/null -w "%{http_code}" "http://localhost:8000/api/v1/server/logs/../../etc/passwd" -H "Authorization: Bearer ${TOKEN}"

# WebSocket test requires wscat or similar:
# wscat -c "ws://localhost:8000/api/v1/server/logs/nginx-access/ws?token=${TOKEN}"
  </verify>
  <done>REST and WebSocket log endpoints work. Invalid log types rejected. WebSocket authenticates via query param token.</done>
</task>

</tasks>

<verification>
1. Log models importable: `python -c "from backend.server.models import LogType, LogEntry"`
2. Log reader importable: `python -c "from backend.server.logs import tail_log, LOG_PATHS"`
3. WebSocket manager importable: `python -c "from backend.server.websocket import log_manager"`
4. Path traversal blocked: `validate_log_type("../etc/passwd")` returns False
5. REST route registered: OpenAPI shows /api/v1/server/logs/{log_type}
6. Auth required: Unauthenticated requests return 401 (REST) or close with 4001 (WebSocket)
</verification>

<success_criteria>
- LogType enum with valid log types
- Hardcoded LOG_PATHS mapping prevents path traversal
- tail_log reads last N lines from log files safely
- GET /api/v1/server/logs/{log_type} returns recent lines
- WebSocket /api/v1/server/logs/{log_type}/ws streams updates
- WebSocket auth via query param token
- Invalid log types return 400 (REST) or close with 4000 (WebSocket)
- Invalid tokens close WebSocket with 4001
</success_criteria>

<output>
After completion, create `.planning/phases/03-server-dashboard/03-03-SUMMARY.md`
</output>
