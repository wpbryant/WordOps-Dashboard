---
phase: 03-server-dashboard
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/server/models.py
  - backend/server/services.py
  - backend/server/routes.py
autonomous: true

must_haves:
  truths:
    - "API returns status for nginx service"
    - "API returns status for php-fpm service(s)"
    - "API returns status for mariadb/mysql service"
    - "API returns status for redis service"
    - "Service status includes active state and memory usage"
    - "Service restart endpoint restarts a service"
    - "Only allowlisted services can be queried or restarted"
  artifacts:
    - path: "backend/server/models.py"
      provides: "ServiceStatus model"
      contains: "class ServiceStatus"
    - path: "backend/server/services.py"
      provides: "systemctl wrapper functions"
      exports: ["get_service_status", "get_all_services", "restart_service"]
    - path: "backend/server/routes.py"
      provides: "Service status endpoints"
      contains: "/services"
  key_links:
    - from: "backend/server/routes.py"
      to: "backend/server/services.py"
      via: "import and call service functions"
      pattern: "from backend.server.services import"
    - from: "backend/server/services.py"
      to: "systemctl"
      via: "asyncio.create_subprocess_exec"
      pattern: "create_subprocess_exec.*systemctl"
---

<objective>
Create backend service status monitoring via systemctl with restart capability.

Purpose: Display service health cards on dashboard showing nginx, php-fpm, mariadb, redis status with memory usage and uptime. Allow safe service restart.

Output: Working `/api/v1/server/services` endpoints for listing status and restarting services.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-server-dashboard/03-RESEARCH.md
@.planning/phases/03-server-dashboard/03-CONTEXT.md

# Existing patterns
@backend/wordops/cli.py
@backend/wordops/routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create service status models and systemctl wrapper</name>
  <files>
    backend/server/models.py
    backend/server/services.py
  </files>
  <action>
**models.py** (add to existing file from 03-01):
- `ServiceStatus` model:
  - `name: str` - service name (e.g., "nginx")
  - `active: bool` - whether service is running
  - `sub_state: str` - systemd sub-state (e.g., "running", "dead")
  - `memory_bytes: int | None` - current memory usage
  - `uptime_seconds: int | None` - time since service started
  - `main_pid: int | None` - process ID

**services.py:**
Create systemctl wrapper following cli.py patterns.

Security: Strict allowlist of services:
```python
ALLOWED_SERVICES = frozenset({
    "nginx",
    "php7.4-fpm", "php8.0-fpm", "php8.1-fpm", "php8.2-fpm", "php8.3-fpm", "php8.4-fpm",
    "mariadb", "mysql",
    "redis-server",
    "postfix",
    "fail2ban",
    "ufw",
    "netdata",
})
```

Functions:
- `def validate_service(name: str) -> bool` - check if in allowlist
- `async def get_service_status(name: str) -> ServiceStatus | None`
  - Validate service name against allowlist (raise ValueError if not)
  - Use `systemctl show {name} --property=ActiveState,SubState,MainPID,MemoryCurrent,ActiveEnterTimestamp`
  - Parse output into ServiceStatus
  - Calculate uptime from ActiveEnterTimestamp
  - Return None if service doesn't exist (ActiveState=inactive and no PID)
- `async def get_all_services() -> list[ServiceStatus]`
  - Iterate ALLOWED_SERVICES
  - Return only services that exist and have status
  - Skip services that return None (not installed)
- `async def restart_service(name: str) -> bool`
  - Validate against allowlist
  - Execute `sudo systemctl restart {name}` with 30s timeout
  - Return True on success, raise on failure

Use asyncio.create_subprocess_exec with list args (NEVER shell=True).
Timeout: 5s for status queries, 30s for restart.
  </action>
  <verify>
python -c "from backend.server.models import ServiceStatus; print('ServiceStatus model OK')"
python -c "from backend.server.services import ALLOWED_SERVICES, validate_service; print('nginx valid:', validate_service('nginx')); print('hack invalid:', validate_service('../../../etc/passwd'))"
  </verify>
  <done>ServiceStatus model and systemctl wrapper functions exist with strict service allowlist</done>
</task>

<task type="auto">
  <name>Task 2: Add service endpoints to routes</name>
  <files>
    backend/server/routes.py
  </files>
  <action>
Add to existing routes.py (from 03-01):

**GET /api/v1/server/services**
- Requires authentication
- Returns: `list[ServiceStatus]`
- Calls `get_all_services()`
- Returns all installed services with their status

**GET /api/v1/server/services/{service_name}**
- Requires authentication
- Path param: `service_name: str`
- Returns: `ServiceStatus`
- Validate service_name against allowlist (400 if invalid)
- Return 404 if service not installed
- Return status for specific service

**POST /api/v1/server/services/{service_name}/restart**
- Requires authentication
- Path param: `service_name: str`
- Returns: `{"success": true, "message": "Service {name} restarted"}`
- Validate service_name against allowlist (400 if invalid)
- Call `restart_service(name)`
- Return 503 if restart fails

Error handling:
- ValueError from services.py -> 400 Bad Request
- RuntimeError from restart -> 503 Service Unavailable
- asyncio.TimeoutError -> 503 with timeout message
  </action>
  <verify>
# Verify routes registered:
curl -s http://localhost:8000/openapi.json | python -c "import sys,json; paths=json.load(sys.stdin)['paths']; print('/api/v1/server/services' in paths, '/api/v1/server/services/{service_name}' in paths)"

# Test services list (requires auth):
curl -s http://localhost:8000/api/v1/server/services -H "Authorization: Bearer ${TOKEN}" | head -20

# Test invalid service (should return 400):
curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/api/v1/server/services/../../etc/passwd -H "Authorization: Bearer ${TOKEN}"
  </verify>
  <done>Service status and restart endpoints work. Invalid service names rejected with 400.</done>
</task>

</tasks>

<verification>
1. ServiceStatus model importable: `python -c "from backend.server.models import ServiceStatus"`
2. Services wrapper importable: `python -c "from backend.server.services import get_all_services, restart_service"`
3. Allowlist enforced: Invalid service names raise ValueError
4. Routes registered: OpenAPI shows /api/v1/server/services endpoints
5. Auth required: Unauthenticated requests return 401
</verification>

<success_criteria>
- ServiceStatus model captures service state, memory, uptime
- Strict allowlist prevents arbitrary service access
- GET /api/v1/server/services returns all installed services
- GET /api/v1/server/services/{name} returns single service status
- POST /api/v1/server/services/{name}/restart restarts service (requires sudo)
- Invalid service names return 400, not found returns 404
</success_criteria>

<output>
After completion, create `.planning/phases/03-server-dashboard/03-02-SUMMARY.md`
</output>
